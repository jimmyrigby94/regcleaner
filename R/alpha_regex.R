#' alpha_regex: Streamline Reliability Analysis with Regular Expressions
#'
#' @description Is a wrapper for alpha from the psych package that conducts reliability analysis on scales identified through regular expressions. Defaults to returning a data frame with most of the main information generated by alpha, but more information can be requested using the robust_output option.
#' @param data A data frame that has been renamed in a way that the column names contain information about the scale and the item number.
#' @param ... Variables that share the naming convention of a subscale but should be dropped from scale calculations. These may include attention check items or raw scores for reverse coded items.
#' @param verbose_output A logical value detailing whether all information generated by alpha should be returned. Defaults to FALSE.
#' @param scale_regex A regular expression that is associated with the scale naming conventions. Defaults to the first capitalized or uncapitalized alphabetic characterers or punctuation.
#' @param item_regex A regular expression that is associated with the item naming conventions. Defaults to the last numeric values, r, or _r.
#'
#' @return A data frame or list (dependent on verbose_output argument) containing reliability information from psych::alpha
#' @importFrom psych alpha
#' @export
#'
#' @examples
#'
#' # Example utlizes the bfi data that loads with the psych package
#' library(tidyverse)
#' bfi<-psych::bfi
#'
#' # Several of the items need to be reverse coded.
#' # I do this by creating new items but retain the old columns in the complete data frame.
#' personality<-bfi%>%
#'               mutate_at(vars(A1, E1, E2, O2, O5, C4, C5),
#'                         .funs = list(r = function(x){7-x}))
#'
#' reliability<-alpha_regex(data = personality, A1, E1, E2, O2, O5, C4, C5)

alpha_regex<-function(data, ..., verbose_output = FALSE, scale_regex="^[A-Za-z[:punct:]]*", item_regex="[0-9]+$|[0-9]+r$|[0-9]+_r"){
  dropquo<-dplyr::enquos(...)

  scaled<-data%>%
    dplyr::mutate(unique_row_id = 1:nrow(data))%>%
    dplyr::mutate_all(.funs = funs(as.numeric))%>%
    dplyr::select(-c(!!!dropquo))%>%
    dplyr::select_if(function(x){is.numeric(x)|is.integer(x)})%>%
    tidyr::gather(key = key, value = value, -unique_row_id)%>%
    dplyr::filter(str_detect(key, item_regex))%>%
    dplyr::mutate(scale = stringr::str_extract(key, scale_regex))%>%
    dplyr::mutate(scale = as.factor(scale))%>%
    dplyr::group_by(scale)%>%
    dplyr::mutate(items =  n_distinct(key))%>%
    dplyr::ungroup()%>%
    dplyr::filter(items>1)

  message("Reliability analysis ran on ", n_distinct(scaled$scale), " scales.\n",
          "Scale Names:\n",
          paste(unique(scaled$scale), collapse = " "))

  listed<-split(scaled, scaled$scale, drop = TRUE)

  alpha<-listed%>%
    purrr::map(~tidyr::spread(., key = key, value = value))%>%
    purrr::map(~dplyr::select(., -unique_row_id, -scale, -items))%>%
    purrr::map(~psych::alpha(.))

  if(!verbose_output){
    alpha_df<-alpha%>%
      purrr::map_dfr(~as.data.frame(.$total))%>%
      dplyr::mutate(scale = names(alpha))%>%
      dplyr::select(scale, dplyr::everything())

    return(alpha_df)
  }else{
    return(alpha)
  }
}
